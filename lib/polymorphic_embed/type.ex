defmodule PolymorphicEmbed.Type do
  @moduledoc "The Ecto.ParameterizedType for polymorphic embeds."

  use Ecto.ParameterizedType

  alias Ecto.Changeset
  alias PolymorphicEmbed.Utils

  @type t() :: any()

  @enforce_keys [:cardinality, :type_field, :types_metadata]

  defstruct [
    :cardinality,
    :type_field,
    :types_metadata,
    default: nil,
    on_type_not_found: :changeset_error,
    nilify_unlisted_types_on_load: [],
    retain_unlisted_types_on_load: []
  ]

  @impl true
  def type(_params), do: :map

  @impl true
  def init(opts) do
    cardinality = Keyword.fetch!(opts, :cardinality)
    {types, opts} = Keyword.pop!(opts, :types)

    if cardinality not in [:one, :many] do
      raise ArgumentError, "cardinality can only be :one or :many, got #{inspect(cardinality)}"
    end

    opts =
      opts
      |> Keyword.put_new(:type_field, :__type__)
      |> Keyword.put(:types_metadata, normalize_types!(types))

    struct(__MODULE__, opts)
  end

  @impl true
  def cast(_data, _params) do
    raise "#{__MODULE__} must not be cast using Ecto.Changeset.cast/4, " <>
            "use #{__MODULE__}.cast_polymorphic_embed/2 instead."
  end

  @impl true
  def embed_as(_format, _params), do: :dump

  @impl true
  def load(nil, _loader, _params), do: {:ok, nil}

  def load(data, loader, %__MODULE__{} = params) when is_map(data),
    do: do_load(data, loader, params)

  def load(data, loader, %__MODULE__{} = params) when is_binary(data),
    do: do_load(Utils.json_library().decode!(data), loader, params)

  @doc false
  @impl true
  def dump(%Changeset{valid?: false}, _dumper, _params) do
    raise "cannot dump invalid changeset"
  end

  def dump(%Changeset{valid?: true} = changeset, dumper, params) do
    dump(Changeset.apply_changes(changeset), dumper, params)
  end

  def dump(%module{} = struct, dumper, %__MODULE__{} = params) do
    case module.__schema__(:autogenerate_id) do
      {key, _source, :binary_id} ->
        unless Map.get(struct, key) do
          raise "polymorphic_embed cannot add an autogenerated key without casting " <>
                  "through cast_polymorphic_embed/3"
        end

      _ ->
        nil
    end

    map =
      struct
      |> map_from_struct()
      # use the atom instead of string form for mongodb
      |> Map.put(params.type_field, Utils.get_polymorphic_type(module, params.types_metadata))

    dumper.(:map, map)
  end

  def dump(nil, dumper, _params), do: dumper.(:map, nil)

  defp map_from_struct(struct), do: Ecto.embedded_dump(struct, :json)

  defp normalize_types!(types) when is_list(types), do: Enum.map(types, &normalize_type!/1)

  defp normalize_type!({type_name, module}) when is_atom(module),
    do: normalize_type!({type_name, module: module})

  defp normalize_type!({type_name, embedded_type}) do
    identify_by_fields =
      case Keyword.fetch(embedded_type, :identify_by_fields) do
        {:ok, [_ | _] = fields} -> Enum.map(fields, &to_string/1)
        _ -> nil
      end

    %{
      type: type_name,
      module: Keyword.fetch!(embedded_type, :module),
      identify_by_fields: identify_by_fields
    }
  end

  defp do_load(data, _loader, %__MODULE__{} = params) do
    type_param = Atom.to_string(params.type_field)

    case Utils.infer_type_from_data(data, type_param, params.types_metadata) do
      nil ->
        retain_type_list = Enum.map(params.retain_unlisted_types_on_load || [], &to_string/1)
        nilify_type_list = Enum.map(params.nilify_unlisted_types_on_load || [], &to_string/1)

        type = Map.get(data, type_param)

        cond do
          type in retain_type_list -> {:ok, data}
          type in nilify_type_list -> {:ok, nil}
          true -> Utils.cannot_infer_type_from_data!(data)
        end

      module when is_atom(module) ->
        {:ok, Ecto.embedded_load(module, data, :json)}
    end
  end
end
